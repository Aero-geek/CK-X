{
  "questions": [
    {
      "id": "1",
      "namespace": "network-security",
      "machineHostname": "ckad9999",
      "question": "Create a NetworkPolicy named `secure-backend` in the `network-security` namespace that restricts access to pods with label `app=backend` to only allow ingress traffic from pods with label `app=frontend` on port 8080.\n\nAdditionally, ensure that these backend pods can only make egress connections to pods with label `app=database` on port 5432.",
      "concepts": ["network policies", "ingress", "egress"],
      "verification": [
        {
          "id": "1",
          "description": "NetworkPolicy exists",
          "verificationScriptFile": "q1_s1_validate_policy_exists.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "NetworkPolicy has correct ingress rules",
          "verificationScriptFile": "q1_s2_validate_ingress.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "NetworkPolicy has correct egress rules",
          "verificationScriptFile": "q1_s3_validate_egress.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "2",
      "namespace": "secure-ingress",
      "machineHostname": "ckad9999",
      "question": "Create a TLS-enabled Ingress resource named `secure-app` in the `secure-ingress` namespace for the service `web-service` (port 80).\n\nThe Ingress should:\n- Respond to the hostname `secure-app.example.com`\n- Use a TLS secret named `secure-app-tls`\n\nThe TLS secret has already been created in the `secure-ingress` namespace.",
      "concepts": ["ingress", "tls"],
      "verification": [
        {
          "id": "1",
          "description": "Ingress exists",
          "verificationScriptFile": "q2_s1_validate_ingress_exists.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Ingress configured with correct hostname",
          "verificationScriptFile": "q2_s2_validate_hostname.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "3",
          "description": "Ingress configured with TLS",
          "verificationScriptFile": "q2_s3_validate_tls.sh",
          "expectedOutput": "0",
          "weightage": 3
        }
      ]
    },
    {
      "id": "3",
      "namespace": "api-security",
      "machineHostname": "ckad9999",
      "question": "Enhance the security of the Kubernetes API server by configuring a Pod Security Policy (PSP) or Pod Security Standard (PSS):\n\n1. Create a namespace named `api-security`\n\n2. Apply a label to the namespace to enforce the `baseline` Pod Security Standard: `pod-security.kubernetes.io/enforce=baseline`\n\n3. Create a pod named `secure-pod` using the `nginx` image that complies with the baseline Pod Security Standard.\n\n4. Create a Role and RoleBinding that allow a ServiceAccount named `pss-viewer` (which has already been created) to view the pod security standards applied to namespaces.",
      "concepts": ["api security", "pod security standards", "rbac"],
      "verification": [
        {
          "id": "1",
          "description": "Namespace exists with correct label",
          "verificationScriptFile": "q3_s1_validate_namespace.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "Secure pod exists",
          "verificationScriptFile": "q3_s2_validate_pod.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "3",
          "description": "Role and RoleBinding exist",
          "verificationScriptFile": "q3_s3_validate_rbac.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "4",
      "namespace": "metadata-protect",
      "machineHostname": "ckad9999",
      "question": "Protect the Kubernetes node metadata from being accessed by pods. Create a NetworkPolicy named `block-metadata` in the `metadata-protect` namespace that blocks outbound access from all pods to the Kubernetes metadata endpoint (usually at 169.254.169.254).\n\nVerify your implementation by creating a pod named `test-pod` in the same namespace using the `busybox` image with a command that sleeps for 3600 seconds.",
      "concepts": ["network policies", "metadata protection"],
      "verification": [
        {
          "id": "1",
          "description": "NetworkPolicy exists",
          "verificationScriptFile": "q4_s1_validate_policy_exists.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "NetworkPolicy blocks metadata access",
          "verificationScriptFile": "q4_s2_validate_blocks_metadata.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Test pod exists",
          "verificationScriptFile": "q4_s3_validate_test_pod.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "5",
      "namespace": "binary-verify",
      "machineHostname": "ckad9999",
      "question": "You need to verify the integrity of Kubernetes binaries before deploying them. In the `binary-verify` namespace, create a pod named `verify-bin` using the `busybox` image that mounts the host's `/usr/bin` directory as a read-only volume at `/host-bin`.\n\nInside the pod, write a script that calculates the SHA256 hash of the following files and stores the results in a file at `/tmp/verified-hashes.txt` within the pod:\n- /host-bin/kubectl\n- /host-bin/kubelet\n\nUse the command format: `sha256sum [file] >> /tmp/verified-hashes.txt`",
      "concepts": ["binary verification", "hostpath volumes"],
      "verification": [
        {
          "id": "1",
          "description": "Pod exists",
          "verificationScriptFile": "q5_s1_validate_pod_exists.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Correct volume mount",
          "verificationScriptFile": "q5_s2_validate_volume_mount.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Hash calculation script works",
          "verificationScriptFile": "q5_s3_validate_hash_calculation.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "6",
      "namespace": "rbac-minimize",
      "machineHostname": "ckad9999",
      "question": "Create a Role and RoleBinding in the `rbac-minimize` namespace to provide a ServiceAccount named `app-reader` with minimal permissions required to read pods, services, and deployments, but not secrets or configmaps.\n\nThe Role should be named `app-reader-role` and the RoleBinding should be named `app-reader-binding`.",
      "concepts": ["rbac", "role", "rolebinding", "least privilege"],
      "verification": [
        {
          "id": "1",
          "description": "Role exists",
          "verificationScriptFile": "q6_s1_validate_role_exists.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Role has correct permissions",
          "verificationScriptFile": "q6_s2_validate_role_permissions.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "RoleBinding exists and is correct",
          "verificationScriptFile": "q6_s3_validate_rolebinding.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "7",
      "namespace": "service-account-caution",
      "machineHostname": "ckad9999",
      "question": "In the `service-account-caution` namespace, create a Deployment named `secure-app` with 2 replicas that uses the `nginx` image.\n\nConfigure the Deployment to use a custom ServiceAccount named `minimal-sa` that you will create. The ServiceAccount should have automounting of API credentials disabled.\n\nAdditionally, configure the Pod template to explicitly disable service account token automounting.",
      "concepts": ["service accounts", "automounting", "least privilege"],
      "verification": [
        {
          "id": "1",
          "description": "ServiceAccount exists",
          "verificationScriptFile": "q7_s1_validate_sa_exists.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "ServiceAccount has automounting disabled",
          "verificationScriptFile": "q7_s2_validate_sa_automounting.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Deployment exists and uses the ServiceAccount",
          "verificationScriptFile": "q7_s3_validate_deployment.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "4",
          "description": "Pod automounting explicitly disabled",
          "verificationScriptFile": "q7_s4_validate_pod_automounting.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "8",
      "namespace": "api-restrict",
      "machineHostname": "ckad9999",
      "question": "Restrict access to the Kubernetes API server by creating a NetworkPolicy named `api-server-policy` in the `api-restrict` namespace that denies all egress traffic to the Kubernetes API server except from pods with the label `role=admin`.\n\nCreate a pod named `admin-pod` with label `role=admin` and a pod named `restricted-pod` with label `role=restricted` in the same namespace. Both pods should use the `busybox` image and sleep for 3600 seconds.",
      "concepts": ["network policies", "api server", "egress control"],
      "verification": [
        {
          "id": "1",
          "description": "NetworkPolicy exists",
          "verificationScriptFile": "q8_s1_validate_policy_exists.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "NetworkPolicy has correct selectors",
          "verificationScriptFile": "q8_s2_validate_policy_selectors.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Admin pod can access API server",
          "verificationScriptFile": "q8_s3_validate_admin_access.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "4",
          "description": "Restricted pod cannot access API server",
          "verificationScriptFile": "q8_s4_validate_restricted_access.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "9",
      "namespace": "os-hardening",
      "machineHostname": "ckad9999",
      "question": "Create a pod named `secure-container` in the `os-hardening` namespace using the `nginx` image with the following security settings:\n\n1. The container should drop ALL capabilities and only add back the `NET_BIND_SERVICE` capability\n2. The container should use a read-only root filesystem\n3. The container should run as user ID 1000 and group ID 3000\n\nEnsure the container can start successfully and serve traffic on port 80.",
      "concepts": ["capabilities", "read-only filesystem", "user context"],
      "verification": [
        {
          "id": "1",
          "description": "Pod exists",
          "verificationScriptFile": "q9_s1_validate_pod_exists.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Pod has correct capabilities configuration",
          "verificationScriptFile": "q9_s2_validate_capabilities.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Pod uses read-only root filesystem",
          "verificationScriptFile": "q9_s3_validate_readonly_fs.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "4",
          "description": "Pod runs as correct user/group",
          "verificationScriptFile": "q9_s4_validate_user_group.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "10",
      "namespace": "seccomp-profile",
      "machineHostname": "ckad9999",
      "question": "Create a pod named `seccomp-pod` in the `seccomp-profile` namespace using the `nginx` image with a seccomp profile applied.\n\nThe seccomp profile should be the default runtime/default profile.\n\nAdditionally, create a ConfigMap named `seccomp-config` in the same namespace with key `profile.json` containing a simple seccomp profile that allows only the following syscalls: `exit`, `exit_group`, `rt_sigreturn`, `read`, `write`, and `open`.",
      "concepts": ["seccomp", "syscalls", "container hardening"],
      "verification": [
        {
          "id": "1",
          "description": "Pod exists with seccomp profile",
          "verificationScriptFile": "q10_s1_validate_pod.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "ConfigMap exists with profile",
          "verificationScriptFile": "q10_s2_validate_configmap.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Seccomp profile allows required syscalls",
          "verificationScriptFile": "q10_s3_validate_syscalls.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "11",
      "namespace": "pod-security",
      "machineHostname": "ckad9999",
      "question": "Label the `pod-security` namespace to enforce the `baseline` Pod Security Standard.\n\nThen, create a pod named `compliant-pod` that complies with the baseline Pod Security Standard.\n\nFinally, attempt to create a pod named `non-compliant-pod` that violates the standard by running as root and with privileged security context. Document the error in a file named `/tmp/violation.txt`.",
      "concepts": ["pod security standards", "namespace labels"],
      "verification": [
        {
          "id": "1",
          "description": "Namespace has correct labels",
          "verificationScriptFile": "q11_s1_validate_namespace_labels.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "Compliant pod exists",
          "verificationScriptFile": "q11_s2_validate_compliant_pod.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "3",
          "description": "Non-compliant pod is rejected",
          "verificationScriptFile": "q11_s3_validate_non_compliant_pod.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "12",
      "namespace": "secrets-management",
      "machineHostname": "ckad9999",
      "question": "Create a Secret named `db-creds` in the `secrets-management` namespace with the following data:\n- username: `admin`\n- password: `SecretP@ssw0rd`\n\nDeploy a pod named `secure-app` that mounts this secret as files at `/etc/db-creds`.\n\nAdditionally, deploy a second pod named `env-app` that exposes the secret data as environment variables with names `DB_USER` and `DB_PASS`.\n\nBoth pods should use the `busybox` image and run the command `sleep 3600`.",
      "concepts": ["secrets", "volume mounts", "environment variables"],
      "verification": [
        {
          "id": "1",
          "description": "Secret exists with correct data",
          "verificationScriptFile": "q12_s1_validate_secret.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "First pod mounts secrets as files",
          "verificationScriptFile": "q12_s2_validate_secure_app.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Second pod has secrets as environment variables",
          "verificationScriptFile": "q12_s3_validate_env_app.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "13",
      "namespace": "tenant-isolation",
      "machineHostname": "ckad9999",
      "question": "Set up multi-tenancy isolation in the cluster by performing the following tasks:\n\n1. Create two namespaces: `tenant-a` and `tenant-b`\n2. Apply resource quotas to both namespaces limiting them to:\n   - 2 pods\n   - 1 CPU core total\n   - 1Gi memory total\n3. Create a NetworkPolicy in each namespace that denies all ingress from the other tenant's namespace\n4. Deploy a pod named `app` in each namespace using the `nginx` image",
      "concepts": ["namespaces", "resource quotas", "network policies", "multi-tenancy"],
      "verification": [
        {
          "id": "1",
          "description": "Namespaces exist",
          "verificationScriptFile": "q13_s1_validate_namespaces.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Resource quotas configured correctly",
          "verificationScriptFile": "q13_s2_validate_quotas.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "NetworkPolicies implemented correctly",
          "verificationScriptFile": "q13_s3_validate_network_policies.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "4",
          "description": "Pods deployed in each namespace",
          "verificationScriptFile": "q13_s4_validate_pods.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "14",
      "namespace": "image-security",
      "machineHostname": "ckad9999",
      "question": "Create a small and secure container image for a simple web application:\n\n1. Create a ConfigMap named `image-specs` in the `image-security` namespace with the following data:\n   - base: `alpine:3.14`\n   - packages: `nginx`\n   - user: `nginx`\n   - entrypoint: `nginx -g 'daemon off;'`\n\n2. Write the Dockerfile contents to a ConfigMap named `dockerfile` with key `Dockerfile` that follows best practices for minimal attack surface:\n   - Uses a minimal base image\n   - Installs only necessary packages\n   - Removes package manager cache\n   - Runs as a non-root user\n   - Uses a read-only root filesystem where possible\n\n3. Create a pod named `secure-image-pod` that uses the `nginx:alpine` image and runs as non-root user 101.",
      "concepts": ["container images", "dockerfile security", "minimal footprint"],
      "verification": [
        {
          "id": "1",
          "description": "ConfigMap image-specs exists",
          "verificationScriptFile": "q14_s1_validate_config_specs.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Dockerfile ConfigMap exists with secure practices",
          "verificationScriptFile": "q14_s2_validate_dockerfile.sh",
          "expectedOutput": "0",
          "weightage": 3
        },
        {
          "id": "3",
          "description": "Pod created with correct security context",
          "verificationScriptFile": "q14_s3_validate_pod.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "15",
      "namespace": "supply-chain",
      "machineHostname": "ckad9999",
      "question": "Secure your supply chain by implementing a policy that only allows images from trusted registries.\n\n1. Create an ImagePolicyWebhook admission configuration in a ConfigMap named `trusted-registries` in the `supply-chain` namespace that only allows images from the following registries:\n   - docker.io/library/\n   - k8s.gcr.io/\n\n2. Create a pod named `verification-pod` using the `busybox` image that runs a script to verify SHA256 digests of critical container images. The script should be stored in a ConfigMap named `verify-script` with key `verify.sh`.",
      "concepts": ["supply chain security", "trusted registries", "image verification"],
      "verification": [
        {
          "id": "1",
          "description": "Trusted registries ConfigMap exists",
          "verificationScriptFile": "q15_s1_validate_trusted_registries.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "Verification pod and script exist",
          "verificationScriptFile": "q15_s2_validate_verification_pod.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Script performs correct verification",
          "verificationScriptFile": "q15_s3_validate_script.sh",
          "expectedOutput": "0",
          "weightage": 1
        }
      ]
    },
    {
      "id": "16",
      "namespace": "static-analysis",
      "machineHostname": "ckad9999",
      "question": "Perform static analysis on a Kubernetes deployment to identify security issues:\n\n1. A deployment manifest is stored in a ConfigMap named `insecure-deployment` in the `static-analysis` namespace.\n\n2. Use kubesec to analyze the deployment and store the results in a ConfigMap named `security-analysis`.\n\n3. Create an improved version of the deployment that fixes at least 3 security issues identified, and apply it as a Deployment named `secure-deployment`.",
      "concepts": ["static analysis", "kubesec", "security best practices"],
      "verification": [
        {
          "id": "1",
          "description": "Analysis results stored in ConfigMap",
          "verificationScriptFile": "q16_s1_validate_analysis.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "Secure deployment applied with fixes",
          "verificationScriptFile": "q16_s2_validate_secure_deployment.sh",
          "expectedOutput": "0",
          "weightage": 3
        }
      ]
    },
    {
      "id": "17",
      "namespace": "runtime-security",
      "machineHostname": "ckad9999",
      "question": "Implement runtime security measures:\n\n1. Create a pod named `immutable-container` in the `runtime-security` namespace using the `nginx:alpine` image with an immutable filesystem (read-only root).\n\n2. Create a pod specification in a ConfigMap named `falco-rules` that would trigger Falco alerts for suspicious activities such as:\n   - Shell execution in a container\n   - Package management use in a container\n   - Sensitive file access\n\n3. Create a DaemonSet named `audit-daemon` that would run on all nodes and monitor for these suspicious activities.",
      "concepts": ["runtime security", "immutability", "behavioral monitoring"],
      "verification": [
        {
          "id": "1",
          "description": "Immutable container exists",
          "verificationScriptFile": "q17_s1_validate_immutable.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "2",
          "description": "Falco rules ConfigMap exists",
          "verificationScriptFile": "q17_s2_validate_falco_rules.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "3",
          "description": "Audit DaemonSet exists",
          "verificationScriptFile": "q17_s3_validate_daemonset.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "18",
      "namespace": "audit-logging",
      "machineHostname": "ckad9999",
      "question": "Configure Kubernetes audit logging:\n\n1. Create an audit policy ConfigMap named `audit-policy` in the `audit-logging` namespace that logs:\n   - All authentication attempts at metadata level\n   - All authorization failures at request level\n   - All pod creation/deletion operations at RequestResponse level\n   - No logging for get/list/watch operations on configmaps or secrets\n\n2. Create a pod named `audit-viewer` that would have the appropriate permissions to view these audit logs.",
      "concepts": ["audit logging", "audit policy", "monitoring"],
      "verification": [
        {
          "id": "1",
          "description": "Audit policy ConfigMap exists",
          "verificationScriptFile": "q18_s1_validate_audit_policy.sh",
          "expectedOutput": "0",
          "weightage": 3
        },
        {
          "id": "2",
          "description": "Audit viewer pod exists",
          "verificationScriptFile": "q18_s2_validate_audit_viewer.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "19",
      "namespace": "malicious-detection",
      "machineHostname": "ckad9999",
      "question": "Implement a system to detect potentially malicious activities in the cluster:\n\n1. Create a ConfigMap named `threat-detection` in the `malicious-detection` namespace with rules for detecting:\n   - Unusual network communication patterns\n   - Crypto mining activities\n   - Privilege escalation attempts\n\n2. Deploy a pod named `detector` using the `busybox` image that would simulate running these detection rules every minute.\n\n3. Create a NetworkPolicy named `isolate-compromised` that would automatically isolate any pod labeled as `security-status=compromised`.",
      "concepts": ["threat detection", "network isolation", "incident response"],
      "verification": [
        {
          "id": "1",
          "description": "Threat detection ConfigMap exists",
          "verificationScriptFile": "q19_s1_validate_threat_rules.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "Detector pod exists",
          "verificationScriptFile": "q19_s2_validate_detector.sh",
          "expectedOutput": "0",
          "weightage": 1
        },
        {
          "id": "3",
          "description": "Isolation NetworkPolicy exists",
          "verificationScriptFile": "q19_s3_validate_isolation_policy.sh",
          "expectedOutput": "0",
          "weightage": 2
        }
      ]
    },
    {
      "id": "20",
      "namespace": "cilium-encryption",
      "machineHostname": "ckad9999",
      "question": "Implement Pod-to-Pod encryption using Cilium:\n\n1. Create a namespace named `secure-comms`.\n\n2. Create a ConfigMap named `cilium-encryption` in the `cilium-encryption` namespace with the following information describing how Cilium encryption works:\n   - Key rotation mechanism\n   - IPSec encryption method\n   - Transparent encryption approach\n\n3. Deploy two pods in the `secure-comms` namespace: `secure-pod-a` and `secure-pod-b` using the `nginx` image with appropriate labels/annotations that would enable Cilium encryption between them. Add appropriate labels/annotations to demonstrate your understanding of Cilium Pod-to-Pod encryption.",
      "concepts": ["cilium", "pod-to-pod encryption", "network security"],
      "verification": [
        {
          "id": "1",
          "description": "Cilium encryption ConfigMap exists",
          "verificationScriptFile": "q20_s1_validate_encryption_config.sh",
          "expectedOutput": "0",
          "weightage": 2
        },
        {
          "id": "2",
          "description": "Secure pods deployed with correct configuration",
          "verificationScriptFile": "q20_s2_validate_secure_pods.sh",
          "expectedOutput": "0",
          "weightage": 3
        }
      ]
    }
  ]
} 